<!DOCTYPE html>
<html lang="fr-fr"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">Lexique | Turbo Tartine Games</title>
<meta property="og:title" content="Lexique | Turbo Tartine Games" />
<meta name="twitter:title" content="Lexique | Turbo Tartine Games" />
<meta itemprop="name" content="Lexique | Turbo Tartine Games" />
<meta name="application-name" content="Lexique | Turbo Tartine Games" />
<meta property="og:site_name" content="Turbo Tartine Games" />

<meta name="description" content="Bienvenu sur mon blog ! Vous y trouverez articles, tutoriels et devlogs, issus de mes peripties de développeur indépendant">
<meta itemprop="description" content="Bienvenu sur mon blog ! Vous y trouverez articles, tutoriels et devlogs, issus de mes peripties de développeur indépendant" />
<meta property="og:description" content="Bienvenu sur mon blog ! Vous y trouverez articles, tutoriels et devlogs, issus de mes peripties de développeur indépendant" />
<meta name="twitter:description" content="Bienvenu sur mon blog ! Vous y trouverez articles, tutoriels et devlogs, issus de mes peripties de développeur indépendant" />

<meta property="og:locale" content="fr-fr" />
<meta name="language" content="fr-fr" />

  <link rel="alternate" hreflang="fr-fr" href="http://localhost:1313/pages/glossary/" title="french" />






<meta name="generator" content="Hugo 0.137.0">

    
    <meta property="og:url" content="http://localhost:1313/pages/glossary/">
  <meta property="og:site_name" content="Turbo Tartine Games">
  <meta property="og:title" content="Lexique">
  <meta property="og:description" content="Anti-Aliasing L’aliasing (ou crénelage) est un artefact visuel indésirable qui se manifeste par un effet d’escalier sur les contours des objets rendus. Il apparaît lors de la rasterisation, une étape spécifique du pipeline graphique.
Pour le réduire, différentes techniques d’anti-aliasing existent, chacune ayant ses forces et ses faiblesses.
Bloom Le bloom est un effet de post-process qui renforce la luminosité des objets brillants en créant un halo diffus autour d’eux. Il simule la manière dont les caméras et l’œil humain perçoivent les fortes sources de lumière.">
  <meta property="og:locale" content="fr_fr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="pages">
    <meta property="article:published_time" content="2025-03-09T06:26:08+01:00">
    <meta property="article:modified_time" content="2025-03-09T06:26:08+01:00">


    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Lexique">
  <meta name="twitter:description" content="Anti-Aliasing L’aliasing (ou crénelage) est un artefact visuel indésirable qui se manifeste par un effet d’escalier sur les contours des objets rendus. Il apparaît lors de la rasterisation, une étape spécifique du pipeline graphique.
Pour le réduire, différentes techniques d’anti-aliasing existent, chacune ayant ses forces et ses faiblesses.
Bloom Le bloom est un effet de post-process qui renforce la luminosité des objets brillants en créant un halo diffus autour d’eux. Il simule la manière dont les caméras et l’œil humain perçoivent les fortes sources de lumière.">


    

    <link rel="canonical" href="http://localhost:1313/pages/glossary/">
    <link href="/style.min.1622d675c43252297dbe4cbaa0a3480f2eb1798c1ac2ca39a3d7e4504625cb62.css" rel="stylesheet">
    <link href="/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css" rel="stylesheet">

    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="http://localhost:1313/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    
    
</head>
<body data-theme = "dark" class="notransition">

<script src="/js/theme.js"></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="http://localhost:1313/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title>Accueil</title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        Accueil
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/projects/">
                        Projets
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/posts/">
                        Articles
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/pages/glossary/">
                        Lexique
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/pages/about/">
                        À propos
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">Lexique</h1>
                
                
                
                <div class="post-meta">
                    <time datetime="2025-03-09T06:26:08&#43;01:00" itemprop="datePublished"> 9 mars 2025 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b>Table des matières</b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#anti-aliasing">Anti-Aliasing</a></li>
    <li><a href="#bloom">Bloom</a></li>
    <li><a href="#cel-shading">Cel Shading</a></li>
    <li><a href="#cpu">CPU</a></li>
    <li><a href="#deferred-lighting">Deferred Lighting</a></li>
    <li><a href="#depth-of-field">Depth of Field</a></li>
    <li><a href="#draw-call">Draw Call</a></li>
    <li><a href="#edge">Edge</a></li>
    <li><a href="#face">Face</a></li>
    <li><a href="#fixed-function">Fixed Function</a></li>
    <li><a href="#fragment-shader">Fragment Shader</a></li>
    <li><a href="#frame">Frame</a></li>
    <li><a href="#fxaa">FXAA</a></li>
    <li><a href="#gpu">GPU</a></li>
    <li><a href="#mesh">Mesh</a></li>
    <li><a href="#morph-target">Morph Target</a></li>
    <li><a href="#motion-blur">Motion Blur</a></li>
    <li><a href="#msaa">MSAA</a></li>
    <li><a href="#n-gone">N-Gone</a></li>
    <li><a href="#niveau-dabstraction">Niveau d&rsquo;Abstraction</a></li>
    <li><a href="#normal-attribute">Normal Attribute</a></li>
    <li><a href="#pipeline-graphique">Pipeline Graphique</a></li>
    <li><a href="#pixel-lighting">Pixel Lighting</a></li>
    <li><a href="#post-process">Post-Process</a></li>
    <li><a href="#quad">Quad</a></li>
    <li><a href="#rasterisation">Rasterisation</a></li>
    <li><a href="#render-target">Render Target</a></li>
    <li><a href="#shader">Shader</a></li>
    <li><a href="#skeletal-animation">Skeletal Animation</a></li>
    <li><a href="#smaa">SMAA</a></li>
    <li><a href="#ssao">SSAO</a></li>
    <li><a href="#taa">TAA</a></li>
    <li><a href="#uv-attribute">UV Attribute</a></li>
    <li><a href="#vertex">Vertex</a></li>
    <li><a href="#vertex-color-attribute">Vertex Color Attribute</a></li>
    <li><a href="#vertex-lighting">Vertex Lighting</a></li>
    <li><a href="#vertex-shader">Vertex Shader</a></li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <h2 id="anti-aliasing">Anti-Aliasing</h2>
<p>L&rsquo;aliasing (ou crénelage) est un artefact visuel indésirable qui se manifeste par un effet d’escalier sur les contours des objets rendus. Il apparaît lors de la rasterisation, une étape spécifique du pipeline graphique.</p>
<p>Pour le réduire, différentes techniques d’anti-aliasing existent, chacune ayant ses forces et ses faiblesses.</p>
<h2 id="bloom">Bloom</h2>
<p>Le bloom est un effet de post-process qui renforce la luminosité des objets brillants en créant un halo diffus autour d’eux. Il simule la manière dont les caméras et l’œil humain perçoivent les fortes sources de lumière.</p>
<h2 id="cel-shading">Cel Shading</h2>
<p>Le cel shading (ou toon shading) est un effet de post-process qui donne à l’image une apparence de dessin animé, avec des contours marqués et des aplats de couleurs uniformes.</p>
<h2 id="cpu">CPU</h2>
<p>Acronyme de Central Processing Unit, le CPU est l’unité de calcul principale d’un ordinateur. Il s’agit tout simplement de votre processeur.</p>
<h2 id="deferred-lighting">Deferred Lighting</h2>
<p>Le deferred lighting est une technique qui consiste à calculer l&rsquo;éclairage dans une seconde passe de rendu, plutôt qu&rsquo;à chaque draw call. En ce sens, je l&rsquo;assimile souvent à un calcule de lumière en post-process (même si cette appellation n’est pas tout à fait rigoureuse).</p>
<p>L’avantage par rapport au vertex lighting et au pixel lighting, c’est que l’éclairage n’est plus calculé à chaque draw call, mais une seule fois à la fin. Cela permet d&rsquo;éviter les calculs inutils en cas d’overdraw (lorsque des draw calls écrasent des fragments calculés précédement).</p>
<p>En résumé, on conserve la précision du pixel lighting, mais à un coût bien plus faible. Le problème, avec cette technique, c&rsquo;est qu&rsquo;elle ne permet pas un rendu correcte de la transparence. C’est pourquoi les moteurs utilisant le deferred lighting doivent combiner cela à d&rsquo;autres solutions pour gérer la transparence.</p>
<p>Termes connexes :
<a href="/pages/glossary/#pixel-lighting">Vertex Lighting</a>
<a href="/pages/glossary/#deferred-lighting">Deferred Lighting</a></p>
<h2 id="depth-of-field">Depth of Field</h2>
<p>Le Depth of Field (ou profondeur de champ) est un effet de post-process qui simule l&rsquo;effet de mise au point d&rsquo;une caméra. Il floute les objets situés en dehors d&rsquo;une plage de distance définie, créant ainsi une impression de profondeur.</p>
<h2 id="draw-call">Draw Call</h2>
<p>Un draw call est une instruction envoyée au GPU pour lui demander de traiter et d&rsquo;afficher un ensemble de primitives géométriques (généralement des triangles) à l&rsquo;écran, ou dans une render target.</p>
<h2 id="edge">Edge</h2>
<p>Une edge (ou arête) est un des élements qui constituent un mesh (ou maillage). Chacune relie deux vertex appartenant a ce dernier.</p>
<p>Les edges ne sont explicitement représentées que dans les logiciels de modélisation 3D. Dans le moteur, elles ne sont présentes que de manière implicite, à travers la définition des triangles.</p>
<p>[mettre une image]</p>
<h2 id="face">Face</h2>
<p>Une face est un des élements qui constituent un mesh (ou maillage). Elle est définie par un cycle d&rsquo;edges fermé appartenant au mesh et représente la plus petite unité de surface visible de ce dernier. En effet, un mesh sans face est invisible.</p>
<p>[mettre une image]</p>
<p>On distingue trois types de faces :</p>
<ul>
<li>Les triangles : C&rsquo;est le seul type pris en charge par les moteurs de jeu (une carte graphique ne sait pas afficher autre chose).</li>
<li>Les quads : Faces composées de quatre vertex. Très utilisés en modélisation, car ils sont faciles à subdiviser et permettent d&rsquo;ajouter des loops facilement.</li>
<li>Les n-gones : Composés de plus de quatre vertex. Généralement à proscrire, car leurs propriétés géométriques les rendent difficiles à manipuler.
[mettre une image]</li>
</ul>
<p>Note : Les faces sont orientées. Sauf configuration particulière, elles ne sont visibles que si on les regarde du bon côté. Le côté visible est déterminé par l&rsquo;ordre des vertex.</p>
<p>[mettre un gif]</p>
<h2 id="fixed-function">Fixed Function</h2>
<p>Autrefois, les GPU n&rsquo;étaient pas programmables. L&rsquo;ensemble du pipeline graphique était &ldquo;gravé en dur&rdquo; directement dans la carte, ce qui signifie que chaque étape qui le compose reposait sur des circuits dédiés :</p>
<ul>
<li>transformation des vertex</li>
<li>rasterisation</li>
<li>éclairage</li>
<li>texturing</li>
<li>&hellip;</li>
</ul>
<p>Le programmeur ne pouvait donc pas modifier ces étapes, seulement les activer, les désactiver ou ajuster certains paramètres via des fonctions prédéfinies : les fameuses fixed functions.</p>
<p>Ce modèle offrait d&rsquo;excellentes performances pour l&rsquo;époque, mais manquait de flexibilité. Pour ajouter de nouvelles fonctionnalités visuelles dans les jeux (éclairage PBR, cel shading&hellip;), il aurait fallut que les fabricants de cartes eux même les implémentent directement dans le matériel, ce qui freinait l&rsquo;innovation.</p>
<p>Les GPU ont donc évolué vers des architectures de plus en plus programmables, intégrant des shader stages au pipeline graphique. D&rsquo;abord avec les vertex shaders et fragment shaders, puis arrivèrent des geometry shaders, tessellation shaders, compute shaders, etc.</p>
<p>Aujourd&rsquo;hui, les fixed function stages n&rsquo;ont pas disparu. Ils restent utilisés pour les étapes où la flexibilité n&rsquo;est pas nécessaire et/ou que les performances sont critiques (rasterisation, depth test, etc.).</p>
<h2 id="fragment-shader">Fragment Shader</h2>
<p>Le fragment shader (aussi appelé pixel shader) est la dernière étape programmable du pipeline graphique. Il détermine la couleur finale des fragments (ou pixels) générés lors de la rasterisation, qui est l&rsquo;étape précédente du pipeline.</p>
<p>Plus d&rsquo;élements ici :
<a href="/posts/ddj_shaders/#3-fragment-shader">Dis donc Jamy : Comment ça marche un shader ?</a></p>
<h2 id="frame">Frame</h2>
<p>Une frame est une image de la scène générée à un instant donné par le moteur graphique (ou renderer). La rapidité avec laquelle ces images sont rendues définit le frame rate, exprimé en fps (frames per second).</p>
<h2 id="fxaa">FXAA</h2>
<p>Le FXAA (Fast Approximate Anti-Aliasing) est une technique d&rsquo;anti-aliasing appliquée en post-traitement. Elle détecte les contours dans l&rsquo;image issue de la passe de rendu principale, puis applique un léger flou à ces endroits pour atténuer l&rsquo;aliasing.</p>
<p>Avantages  :</p>
<ul>
<li>Faible impact sur les performances</li>
<li>Compatible avec un deferred renderer (moteur graphique utilisant une architcture particulière permettant le deferred lighting)</li>
</ul>
<p>Inconvénients  :</p>
<ul>
<li>Moins efficace que d&rsquo;autres techniques d&rsquo;anti-aliasing</li>
<li>Peut entraîner un léger flou de l&rsquo;image</li>
</ul>
<h2 id="gpu">GPU</h2>
<p>Acronyme de Graphics Processing Unit, le GPU est l&rsquo;unité de calcul dédiée aux traitements graphiques d&rsquo;un ordinateur. Il s&rsquo;agit tout simplement de la carte graphique.</p>
<h2 id="mesh">Mesh</h2>
<p>Les objets 3d qui compose une scène sont composés d&rsquo;un ou pluieurs meshes (ou maillage en français). Il s&rsquo;agit d&rsquo;un enssemble de <em>vertex</em> (ou sommets) reliés entre eux par des edges (arètes). Si on s&rsquo;arrête là, on est plus ou moins sur la définition d&rsquo;un graphe. Mais il y a deux grandes différences :</p>
<ul>
<li>les vertex d&rsquo;un mesh portent une coordonnée 3d (ou 2d) qui les fixe en un point de l&rsquo;espace (ou du plan)</li>
<li>les cycles fermés d&rsquo;arrêtes peuvent (ou non) definire des faces. Donnant ainsi au mesh une surface.</li>
</ul>
<p>Les objets 3D qui composent une scène sont constitués d&rsquo;un ou plusieurs meshes (ou maillages en français). Un mesh est un ensemble de vertex (sommets) reliés entre eux par des edges (arêtes). Bien que cela ressemble à la définition d&rsquo;un graphe, il y a deux différences majeures :</p>
<ul>
<li>Les vertex d&rsquo;un mesh ont une coordonnée en 3D (ou 2D), ce qui les localisent en des points spécifiques de l&rsquo;espace (ou du plan).</li>
<li>Les cycles fermés d&rsquo;arêtes peuvent (ou non) former des faces, donnant ainsi au mesh une surface.</li>
</ul>
<p>[mettre une image]</p>
<p>Les meshes utilisés dans les moteurs de jeu ont une spécificité supplémentaire : leurs faces doivent impérativement être des triangles, car les cartes graphiques ne gèrent que cette forme. Il est donc nécessaire de trianguler les quads et n-gons avant de les intégrer dans une scène. Cette opération peut être effectuée :</p>
<ul>
<li>Lors de l&rsquo;exportation depuis le logiciel de modélisation,</li>
<li>Ou à l&rsquo;importation dans le moteur de jeu.</li>
</ul>
<p>[même image triangulée]</p>
<h2 id="morph-target">Morph Target</h2>
<p>L’animation par morph target (ou blend shape) est une technique qui consiste à créer plusieurs versions d’un même mesh. Chaque version, conserve la même topologie que le mesh d’origine (c’est-à-dire le nombre de vertex et la façon dont ils sont connectés entre eux par les edges), seules les positions des vertex sont modifiées.</p>
<p>Lors de l’exécution, des poids sont attribués à chaque version du mesh. En ajustant ces poids progressivement, on fait passer le mesh d&rsquo;une version à l&rsquo;autre de manière fluide. Il est également possible de mélanger plusieurs version si nécessaire.</p>
<p>[mettre une image]</p>
<p>Cette technique est principalement utilisée pour des déformations relativement simples et de petite envergure, comme :</p>
<ul>
<li>l’animation faciale,</li>
<li>le gonflement ou la rétraction des muscles,</li>
<li>des pustules qui palpitent sur le dos d’un monstre,</li>
<li>l’ajustement de la corpulence d’un personnage dans un écran de personnalisation d’avatar.</li>
</ul>
<h2 id="motion-blur">Motion Blur</h2>
<p>Le motion blur (ou flou de mouvement) est un effet de post-traitement qui accentue la sensation de vitesse en floutant les objets proportionnellement à leur vitesse relative par rapport à la caméra.</p>
<h2 id="msaa">MSAA</h2>
<p>Le MSAA (Multi Sampling Anti-Aliasing) est une technique d&rsquo;anti-aliasing gravée en dur dans les circuits du GPU. Elle agit à la source du problème : l’étape de rasterisation.</p>
<p>Lorsqu’un pixel est partiellement couvert par un triangle, plutôt que de l’ignorer, le rasterizer affine son échantillonnage et génère un fragment dont les attributs (couleur, normale, UV, etc.) sont une moyenne des valeurs de chaque échantillon. Lorsque l’on parle de MSAA 2x, 4x, 8x, etc., le chiffre désigne le nombre d’échantillons supplémentaires utilisés pour générer ce fragment. Plus le nombre est élevé, plus le résultat est précis, mais plus la rasterisation est coûteuse.</p>
<p>Avantages :</p>
<ul>
<li>Implémentés directement dans le hardware, ce qui la rend très performante.</li>
<li>Applique le suréchantillonnage uniquement aux contours, plutôt qu’à toute l’image, ce qui limite son coût.</li>
</ul>
<p>Inconvénients :</p>
<ul>
<li>Ne lisse que les contours.</li>
<li>Incompatible avec un deferred renderer (moteur graphique utilisant une architcture particulière permettant le deferred lighting)</li>
</ul>
<h2 id="n-gone">N-Gone</h2>
<p>Dans un logiciel de modélisation 3D, un n-gone désigne une face composée de plus de 4 vertex. Il est généralement déconseillé de les utiliser, surtout si le modèle est destiné à être importé dans un moteur de jeu. Voici quelques raisons pour lesquelles les n-gones posent problème :</p>
<ul>
<li>La triangulation automatique devient plus complexe et les résultats sont difficiles à prévoir.</li>
<li>Si le modèle est animé, les déformations des n-gones peuvent être incorrectes.</li>
<li>Ils présentent des propriétés géométriques qui rendent leur manipulation difficile (par exemple, ils sont compliqués à subdiviser ou d&rsquo;y insérer des loops).</li>
</ul>
<p>Note : Techniquement, un n-gone désigne un polygone à &ldquo;n&rdquo; côtés. Par conséquent, les triangles et les quadrilatères sont aussi des N-Gones au sens mathématique du terme. Toutefois, dans le contexte de la modélisation 3D, on considère un polygone comme un n-gone à partir de 5 côtés, car c&rsquo;est à partir de ce nombre que la géométrie est problématique.</p>
<h2 id="niveau-dabstraction">Niveau d&rsquo;Abstraction</h2>
<p>Le niveau d&rsquo;abstraction d&rsquo;un langage informatique désigne sa proximité avec la logique humaine. Plus un langage est de haut niveau, plus il est lisible et compréhensible &ldquo;facilement&rdquo;. À l&rsquo;inverse, plus un langage est de bas niveau, plus il les briques qui le composesont primitives, ce qui rend les programmes longs et complexes, même pour des tâches simples.</p>
<p>Le langage le plus bas niveau que l&rsquo;on puisse trouver est le langage machine :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">10110000</span> <span class="mo">01100001</span>
</span></span><span class="line"><span class="cl"><span class="mo">00000001</span> <span class="mo">00000010</span>
</span></span><span class="line"><span class="cl"><span class="mi">10000111</span> <span class="mo">01101000</span>
</span></span><span class="line"><span class="cl"><span class="mo">00000001</span> <span class="mo">01100010</span>
</span></span><span class="line"><span class="cl"><span class="mi">10000111</span> <span class="mo">01101000</span>
</span></span><span class="line"><span class="cl"><span class="mo">00011001</span> <span class="mo">01111010</span>
</span></span><span class="line"><span class="cl"><span class="mi">10000111</span> <span class="mo">01101000</span>
</span></span><span class="line"><span class="cl"><span class="mi">10110000</span> <span class="mo">01100001</span>
</span></span><span class="line"><span class="cl"><span class="mo">00000001</span> <span class="mo">00000010</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></div><p>Cet exemple n&rsquo;est pas un vrai programme. C&rsquo;est juste une suites aléatoires de 1 et de 0 que j&rsquo;ai inventée, mais cela ne change rien à l’essentiel : personne n&rsquo;écrit de code directement sous cette forme. Le langage machine est le produit de la compilation, qui traduit automatiquement un code source écrit dans un langage de plus haut niveau.</p>
<p>Un niveau d&rsquo;abstraction plus élevé, qui permet une utilisation humaine, est l&rsquo;assembleur :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">SECTION</span> <span class="no">.data</span>
</span></span><span class="line"><span class="cl">    <span class="nf">extern</span> <span class="no">printf</span>
</span></span><span class="line"><span class="cl">    <span class="nf">global</span> <span class="no">main</span>
</span></span><span class="line"><span class="cl"><span class="nl">fmt:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">db</span> <span class="err">&#34;</span><span class="nv">%d</span><span class="err">&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="nf">SECTION</span> <span class="no">.text</span>
</span></span><span class="line"><span class="cl"><span class="nl">main:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">14</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="no">ebx</span><span class="p">,</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">ebx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span>    <span class="no">eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span>    <span class="no">fmt</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span>    <span class="no">printf</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">int</span>     <span class="mi">0x80</span>
</span></span></code></pre></div><p>C&rsquo;est encore trop difficile à comprendre pour moi. J&rsquo;ai récupéré ce code sur Internet, et apparemment, il permet d&rsquo;additionner les entiers 14 et 10, puis d&rsquo;afficher le résultat dans la console.</p>
<p>Au-dessus de l&rsquo;assembleur, on trouve les langages de programmation traditionnels (comme C, C++, Python, Java, JavaScript…). Ces langages sont beaucoup plus accessibles. Par exemple, en C, le code assembleur ci-dessus se traduirait ainsi :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="mi">14</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Il est important de noter que tous les langages traditionnels ne se situent pas exactement au même niveau d&rsquo;abstraction. Par exemple, le C est un langage plus bas niveau que le Java. Cependant, les différences sont plus subtiles que dans les exemples précédents.</p>
<h2 id="normal-attribute">Normal Attribute</h2>
<p>C&rsquo;est un type d&rsquo;attribut couramment associé aux vertex. Il décrit l&rsquo;orientation de la surface du mesh à la position du vertex. C&rsquo;est une moyenne pondérée des normales des triangles qui lui sont adjacents. Différents types de pondération peuvent être utilisés :</p>
<ul>
<li>Pondération par l&rsquo;aire des triangles</li>
<li>Pondération par l&rsquo;angle au vertex</li>
<li>Pondération en fonction du matériau</li>
<li>Mélange de ces méthodes</li>
</ul>
<p>Les normales sont principalement utilisées dans le calcul de l&rsquo;éclairage. Le fait que ces normales soient partagées par les triangles adjacents donne un aspect lisse à la surface lorsqu&rsquo;elle est éclairée.</p>
<p>[mettre une image smooth]</p>
<p>Cependant, dans certains cas, on souhaite que certaines arêtes soient saillantes. Pour cela, il suffit de dupliquer les vertex de l&rsquo;arête et d&rsquo;attribuer à chaque copie la normale d&rsquo;une des faces adjacentes.</p>
<p>[mettre une image sharp]</p>
<p>Cet attribut est généralement calculé automatiquement par le logiciel de modélisation 3D, selon l&rsquo;agencement des vertex, edges et faces du mesh. Les arêtes saillantes peuvent être détectées automatiquement en fonction de l&rsquo;angle entre deux faces adjacentes, ou être définies manuellement par l&rsquo;artiste en marquant des arêtes comme soft ou sharp, ou en créant des smoothing groups.</p>
<h2 id="pipeline-graphique">Pipeline Graphique</h2>
<p>Le pipeline graphique est une séquence d&rsquo;étapes exécutées par le GPU lors d&rsquo;un draw call. Son rôle est de transformer les vertices 3D en pixels affichés à l&rsquo;écran.</p>
<p>Certaines de ces étapes sont directement gravées dans les circuits du GPU (les fixed function stages), tandis que d&rsquo;autres sont programmables (shader stages).</p>
<h2 id="pixel-lighting">Pixel Lighting</h2>
<p>C&rsquo;est une technique qui consiste à calculer l&rsquo;éclairage au niveau du fragment shader pour chaque draw call de la passe principale.</p>
<p>Grâce à cette méthode, l&rsquo;éclairage ne dépendant plus de la densité de vertex de la surface éclairée, car l&rsquo;illumination est calculée directement au niveau du pixel. Cependant, cette technique est plus coûteuse, car le calcul est effectué pour chaque pixel, et non pour chaque vertex (et en principe il y en a beaucoup plus)</p>
<p>[Mettre une image]</p>
<p>Termes connexes :
<a href="/pages/glossary/#pixel-lighting">Vertex Lighting</a>
<a href="/pages/glossary/#deferred-lighting">Deferred Lighting</a></p>
<h2 id="post-process">Post-Process</h2>
<p>Un post-process est une passe de rendu durant laquelle un traitement est appliqués à un rendu intermédiaire de la scène. Ce rendu est stocké dans une render target, qui a été générée lors d&rsquo;une passe précédente.</p>
<p>De nombreux effets visuels sont réalisés de cette manière (Depth of field, Color Grading, Film Grain, Vignetting etc.)</p>
<h2 id="quad">Quad</h2>
<p>Un quad est une face d&rsquo;un mesh (maillage) composée de quatre edges (arêtes) et de quatre vertex (sommets). Contrairement à un triangle, un quad n&rsquo;est pas nécessairement planaire (c&rsquo;est-à-dire qu&rsquo;il peut ne pas être contenu dans un seul plan).</p>
<p>[mettre une image]</p>
<p>Dans un moteur de jeu qui ne comprend que des triangles, le quad est une primitive géométrique prédéfinie qui est décomposée en deux triangles, partageant deux de leurs vertex (pour un total de quatre vertex). Dans ce cas, le quad est toujours planaire, et il forme un carré ou un rectangle.</p>
<p>[mettre une image]</p>
<h2 id="rasterisation">Rasterisation</h2>
<p>La rasterisation est le processus de transformation d&rsquo;une image vectorielle (définie par des primitives géométriques) en une image matricielle, (composée de pixels).</p>
<p>Dans le cadre de la pipeline graphique, il s&rsquo;agit du fixed function stage située entre le vertex shader et le fragment shader. Cette étape rasterise des triangles, définis par les vertex en espace écran issus du vertex shader. Les pixels générés, aussi appelés fragments, sont ensuite envoyés en entrée du fragment shader.</p>
<p>Les attributs associés aux vertex sont également interpolés et affectés aux fragments correspondants.</p>
<p>Note : Le terme &ldquo;rasterisation&rdquo; est parfois utilisé pour désigner l&rsquo;ensemble du processus de rendu temps réel classique. Dans ce cas, il fait référence à la méthode de rendu dans son intégralité, par opposition à la méthode de rendu par ray tracing.</p>
<h2 id="render-target">Render Target</h2>
<p>Une render target est une toile sur laquelle le pipeline graphique va peindre une séquence de draw calls. À la fin de cette séquence (appelée &ldquo;passe de rendu&rdquo;), cette toile peut soit :</p>
<ul>
<li>
<ol>
<li>être affichée à l&rsquo;écran,</li>
</ol>
</li>
<li>
<ol start="2">
<li>être stockée comme résultat intermédiaire et utilisée lors de la passe de rendu suivante.</li>
</ol>
</li>
</ul>
<p>Le second cas permet d&rsquo;implémenter des effets avancés tels que les ombres dynamiques, les réflexions planaires, et de nombreux effets de post-process (bloom, cel shading, SSAO, anti-aliasing, etc.).</p>
<p>Note : Dans le contexte d&rsquo;un moteur de jeu, le terme désigne généralement le second cas.</p>
<h2 id="shader">Shader</h2>
<p>Un shader est un programme qui s&rsquo;exécute sur le GPU. Le terme fait l&rsquo;objet d&rsquo;une légère ambiguité. Selon le contexte, il designe :</p>
<ul>
<li>un shader stage : un programme indépendant et spécialisé qui collabore avec d&rsquo;autres dans au sein du pipeline graphique pour générer des images (par exemple, le vertex shader, geometry shader, fragment shader, tessellation shader, etc.)</li>
<li>un shader program : un ensemble cohérent de shader stages destinés à être exécutés ensemble. Il s&rsquo;agit, en quelque sorte, d&rsquo;une instance du pipeline graphique.</li>
</ul>
<p>Dans les moteurs de jeux et les logiciels de modélisation, le terme apparaît généralement à travers le concept de material. Dans ce cas, il est souvent employé au sens de shader program. Un material étant vu comme un preset de paramètres pour un shader program donné.</p>
<p>Dans des contextes plus techniques, il est plutôt utilisé dans le sens de shader stage.</p>
<p>Plus d&rsquo;élements ici :
<a href="/posts/ddj_shaders/">Dis donc Jamy : Comment ça marche un shader ?</a></p>
<h2 id="skeletal-animation">Skeletal Animation</h2>
<p>L&rsquo;animation squeletale est une technique d&rsquo;animation qui consiste à associer un squelette à un modèle 3D afin de le déformer. Chaque vertex du modèle est associé à des poids qui déterminent l&rsquo;influence des os proches sur celui-ci (ce processus est appelé skinning).</p>
<p>[mettre une image]</p>
<p>Lorsque l&rsquo;on anime le squelette, chaque os entraîne avec lui les vertex du mesh qu&rsquo;il influence, provoquant ainsi la déformation du modèle 3D.</p>
<p>[mettre une image]</p>
<p>Cette technique est couramment utilisée pour des animations complexes et de grande envergure, comme marcher, sauter ou effectuer des mouvements divers. Elle peut être implémentée soit côté CPU, soit côté GPU, selon les besoins.</p>
<p>Par exemple, si le gameplay nécessite une détection précise des collisions sur la géométrie du mesh, il est nécessaire de le déformer côté CPU. En revanche, si une détection de collision approximative suffit, on peut se contanteer d&rsquo;associaer des colliders simplifiés (spheres, capsules etc.) aux os du squelette et appliquer la déformation du mesh côté GPU.</p>
<h2 id="smaa">SMAA</h2>
<p>Le SMAA (Subpixel Morphological Anti-Aliasing) est une technique d&rsquo;anti-aliasing appliquée en post-process. Comme le FXAA, elle analyse l&rsquo;image issue de la passe de rendu principale pour détecter les contours et appliquer un flou pour adoucir les bords.</p>
<p>Cependant, la détection des contours du SMAA est basée sur des algorithmes plus sophistiqués qui reconnaissent des motifs prédéfinis, offrant ainsi une meilleure précision que le FXAA. Cela permet de réduire les faux positifs et de produire une image moins floue.</p>
<p>Avantages :</p>
<ul>
<li>Une image plus nette qu&rsquo;avec le FXAA</li>
<li>Compatible avec un deferred renderer (moteur graphique utilisant une architcture particulière permettant le deferred lighting)</li>
</ul>
<p>Inconvénients :</p>
<ul>
<li>Plus lourd que le FXAA</li>
</ul>
<h2 id="ssao">SSAO</h2>
<p>L&rsquo;occlusion ambiante est un phénomène physique qui selon lequel la lumière se diffuse moins dans les espaces confinés. Par exemple, dans les coins de murs, à la base d&rsquo;une touffe d&rsquo;herbe ou dans les interstices entre des briques, on observe une lumière moins intense que dans les zones plus dégagées (même sans ombre directe).</p>
<p>Le SSAO (Screen Space Ambient Occlusion) est un effet de post-process qui simule ce phénomène.</p>
<h2 id="taa">TAA</h2>
<p>Le TAA (Anti-Aliasing Temporel) est une technique d&rsquo;anti-aliasing appliquée en post-process. Elle consiste à exploiter les frames précédentes pour lisser l&rsquo;image.</p>
<p>Avantages  :</p>
<ul>
<li>Rendu très précis : les contours sont bien lissés et le reste de l&rsquo;image reste net.</li>
<li>Compatible avec un deferred renderer (moteur graphique utilisant une architcture particulière permettant le deferred lighting)</li>
</ul>
<p>Inconvénients :</p>
<ul>
<li>Sujet au ghosting (effet de traînées floues sur les objets en mouvement).</li>
<li>Peut être plus coûteux en ressources par rapport à d&rsquo;autres techniques.</li>
</ul>
<h2 id="uv-attribute">UV Attribute</h2>
<p>C&rsquo;est un type d&rsquo;attribut couramment associé aux vertex. Il représente une coordonnée 2D, correspondant à une position dans une texture.</p>
<p>C&rsquo;est un type d&rsquo;attribut courrament associé aux vertex. Il représente généralement une coordonnée 2d qui correspont à une position dans une texture. C&rsquo;est grâce à cette information qu&rsquo;on va pouvoir appliquer la texture au mesh. C&rsquo;est grâce à cet attribut que l&rsquo;on peut appliquer une texture sur un mesh, un processus appelé &ldquo;texture mapping&rdquo;.</p>
<p>En résumé, par la magie de l&rsquo;interpolation (réalisée lors de la rasterization), les coordonnées UV sont associées à chaque fragment. Le fragment shader, ayant accès à ces coordonnées UV interpolées, peut alors échantillonner (ou &ldquo;sampler&rdquo;) la texture au point indiqué, afin de déterminer la couleur du pixel à afficher à l&rsquo;écran.</p>
<p>[mettre une image]</p>
<p>Les vertex peuvent porter plusieurs UV différents, car il est possible d&rsquo;appliquer plusieurs textures à un même mesh. Par exemple, une texture pour la lumière statique pré-calculée, stockée dans une texture appelée une lightmap.</p>
<h2 id="vertex">Vertex</h2>
<p>Un vertex (ou sommet) est un des élements qui constituent un mesh (ou maillage). Il représente un point dans l&rsquo;espace ou dans le plan. Un vertex peut posséder plusieurs attributs, dont les plus courants sont :</p>
<ul>
<li>Une couleur</li>
<li>Une normale</li>
<li>Des coordonnées UV</li>
</ul>
<p>Il existe également d&rsquo;autres attributs moins fréquents, comme les poids de skinning utilisées pour l&rsquo;animation. En résumé, un vertex est une coordonnée de l&rsquo;espace ou du plan qui porte de l&rsquo;information.</p>
<p>Note : Le pluriel de &ldquo;vertex&rdquo; est &ldquo;vertices&rdquo;, ne soyez pas surpris de le voir écrit sous cette forme. Mais dans le langage courant (du moins en France) on dit prèsque toujours vertex. Je l&rsquo;utilise donc prèsque toujours sous cette forme y compris à l&rsquo;écrit, autant par habitude que parce que je trouve ça moins confus (désolé pour vos oreilles et vos yeux si vous n&rsquo;êtes pas de cet avis).</p>
<h2 id="vertex-color-attribute">Vertex Color Attribute</h2>
<p>C&rsquo;est un type d&rsquo;attribut couramment associé aux vertex. Il représente (comme son nom l&rsquo;indique) une couleur. Cette couleur est interpolée lors de la rasterisation, créant ainsi un dégradé dont chaque couleur est associée au fragment correspondant.</p>
<p>Bien que cet attribut soit peu utilisé de manière directe dans les jeux modernes, il est souvent détourné pour encoder des informations nécessaires à certaines techniques ou effets. L&rsquo;exemple le plus courant est le vertex painting, qui consiste à peindre les sommets d&rsquo;un objet pour appliquer un effet localisé (comme des salissures, du sang ou de la mousse sur une roche).</p>
<h2 id="vertex-lighting">Vertex Lighting</h2>
<p>C&rsquo;est une technique qui consiste à calculer l&rsquo;éclairage au niveau du vertex shader pour chaque drawcall de la passe principale. La valeur d&rsquo;illumination obtenue est ensuite interpolée par le rasterizer et appliquée à chaque fragment. Le fragment shader peut alors utiliser cette valeur interpolée pour ajuster la couleur du pixel et déterminer sa couleur finale.</p>
<p>L&rsquo;avantage de cette technique est sa faible coût en termes de performances. Cependant, la qualité du rendu dépend de la densité des vertex de la surface éclairée.</p>
<p>[Mettre une image]</p>
<p>Termes connexes :
<a href="/pages/glossary/#pixel-lighting">Pixel Lighting</a>
<a href="/pages/glossary/#deferred-lighting">Deferred Lighting</a></p>
<h2 id="vertex-shader">Vertex Shader</h2>
<p>Le vertex shader est la première étape programmable du pipeline graphique. Traditionnellement, sa fonction principale est de réaliser une série de transformations géométriques sur les vertex qu&rsquo;il traite, afin de les convertir de leurs coordonnée locale en 3d vers l&rsquo;espace 2d de l&rsquo;écran.</p>
<p>Après cette étape, on peut considérer que les vertex forment une sorte d&rsquo;image vectorielle prête à être rasterisée. Cela dit, certaines étapes optionnelles du pipeline, comme le geometry shader et la tessellation, peuvent être appliquées avant la rasterisation.</p>
<p>Plus d&rsquo;élements ici :
<a href="/posts/ddj_shaders/#1-vertex-shader">Dis donc Jamy : Comment ça marche un shader ?</a></p>

            </div>
        </article></main>
</div>
<footer class="footer">
    <span class="footer_item"> </span>
    &nbsp;

    <div class="footer_social-icons">
<a href="https://github.com/J-Ponzo" target="_blank" rel="noopener noreferrer me"
    title="Github">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
</a>
<a href="https://jponzo.itch.io" target="_blank" rel="noopener noreferrer me"
    title="Itchio">
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 245.371 220.736">
    <path
        d="M31.99 1.365C21.287 7.72.2 31.945 0 38.298v10.516C0 62.144 12.46 73.86 23.773 73.86c13.584 0 24.902-11.258 24.903-24.62 0 13.362 10.93 24.62 24.515 24.62 13.586 0 24.165-11.258 24.165-24.62 0 13.362 11.622 24.62 25.207 24.62h.246c13.586 0 25.208-11.258 25.208-24.62 0 13.362 10.58 24.62 24.164 24.62 13.585 0 24.515-11.258 24.515-24.62 0 13.362 11.32 24.62 24.903 24.62 11.313 0 23.773-11.714 23.773-25.046V38.298c-.2-6.354-21.287-30.58-31.988-36.933C180.118.197 157.056-.005 122.685 0c-34.37.003-81.228.54-90.697 1.365zm65.194 66.217a28.025 28.025 0 0 1-4.78 6.155c-5.128 5.014-12.157 8.122-19.906 8.122a28.482 28.482 0 0 1-19.948-8.126c-1.858-1.82-3.27-3.766-4.563-6.032l-.006.004c-1.292 2.27-3.092 4.215-4.954 6.037a28.5 28.5 0 0 1-19.948 8.12c-.934 0-1.906-.258-2.692-.528-1.092 11.372-1.553 22.24-1.716 30.164l-.002.045c-.02 4.024-.04 7.333-.06 11.93.21 23.86-2.363 77.334 10.52 90.473 19.964 4.655 56.7 6.775 93.555 6.788h.006c36.854-.013 73.59-2.133 93.554-6.788 12.883-13.14 10.31-66.614 10.52-90.474-.022-4.596-.04-7.905-.06-11.93l-.003-.045c-.162-7.926-.623-18.793-1.715-30.165-.786.27-1.757.528-2.692.528a28.5 28.5 0 0 1-19.948-8.12c-1.862-1.822-3.662-3.766-4.955-6.037l-.006-.004c-1.294 2.266-2.705 4.213-4.563 6.032a28.48 28.48 0 0 1-19.947 8.125c-7.748 0-14.778-3.11-19.906-8.123a28.025 28.025 0 0 1-4.78-6.155 27.99 27.99 0 0 1-4.736 6.155 28.49 28.49 0 0 1-19.95 8.124c-.27 0-.54-.012-.81-.02h-.007c-.27.008-.54.02-.813.02a28.49 28.49 0 0 1-19.95-8.123 27.992 27.992 0 0 1-4.736-6.155zm-20.486 26.49l-.002.01h.015c8.113.017 15.32 0 24.25 9.746 7.028-.737 14.372-1.105 21.722-1.094h.006c7.35-.01 14.694.357 21.723 1.094 8.93-9.747 16.137-9.73 24.25-9.746h.014l-.002-.01c3.833 0 19.166 0 29.85 30.007L210 165.244c8.504 30.624-2.723 31.373-16.727 31.4-20.768-.773-32.267-15.855-32.267-30.935-11.496 1.884-24.907 2.826-38.318 2.827h-.006c-13.412 0-26.823-.943-38.318-2.827 0 15.08-11.5 30.162-32.267 30.935-14.004-.027-25.23-.775-16.726-31.4L46.85 124.08C57.534 94.073 72.867 94.073 76.7 94.073zm45.985 23.582v.006c-.02.02-21.863 20.08-25.79 27.215l14.304-.573v12.474c0 .584 5.74.346 11.486.08h.006c5.744.266 11.485.504 11.485-.08v-12.474l14.304.573c-3.928-7.135-25.79-27.215-25.79-27.215v-.006l-.003.002z" />
</svg>
</a>
<a href="https://@turbotartine.bsky.social" target="_blank" rel="noopener noreferrer me"
    title="Bluesky">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
    d="M11.999,10.236c0.321,-0.524 0.916,-1.507 1.405,-2.376c0.755,-1.344 1.692,-2.852 2.869,-4.028c1.283,-1.281 2.845,-2.171 4.739,-2.171c1.144,-0 1.864,0.585 2.299,1.497c0.486,1.017 0.545,2.551 0.51,3.883c-0.051,1.945 -0.232,3.337 -0.505,4.275c-0.229,0.786 -0.543,1.303 -0.878,1.615c-0.892,0.833 -1.8,1.263 -2.634,1.484c0.029,0.018 0.056,0.036 0.084,0.055c0.528,0.367 0.823,0.79 1.081,1.107c0.648,0.794 0.644,1.795 0.23,2.784c-0.481,1.151 -1.533,2.279 -2.12,2.773c-1.389,1.171 -2.506,1.362 -3.383,1.133c-0.88,-0.23 -1.59,-0.932 -2.156,-1.826c-0.45,-0.71 -0.817,-1.537 -1.176,-2.186c-0.115,-0.208 -0.302,-0.455 -0.406,-0.587c-0.02,0.019 -0.04,0.04 -0.056,0.058c-0.121,0.145 -0.234,0.328 -0.349,0.531c-0.363,0.644 -0.721,1.463 -1.157,2.166c-0.555,0.895 -1.252,1.597 -2.12,1.825c-0.863,0.227 -1.97,0.037 -3.363,-1.136c-0.586,-0.494 -1.638,-1.622 -2.119,-2.773c-0.414,-0.989 -0.418,-1.99 0.229,-2.784c0.258,-0.317 0.554,-0.74 1.082,-1.106c0.027,-0.019 0.055,-0.038 0.084,-0.056c-0.834,-0.221 -1.742,-0.651 -2.634,-1.484c-0.335,-0.312 -0.649,-0.829 -0.878,-1.615c-0.273,-0.938 -0.454,-2.33 -0.505,-4.275c-0.036,-1.332 0.024,-2.866 0.509,-3.883c0.435,-0.912 1.156,-1.497 2.3,-1.497c2.32,0 4.109,1.203 5.494,2.808c1.272,1.474 2.195,3.283 2.9,4.643c0.231,0.447 0.436,0.84 0.624,1.146Zm-0.01,5.653l0.296,0.031l0.271,0.086c0.208,0.088 0.413,0.229 0.607,0.428c0.455,0.467 0.882,1.369 1.36,2.284c0.249,0.477 0.518,0.958 0.841,1.339c0.231,0.274 0.483,0.502 0.805,0.569c0.488,0.103 1.052,-0.157 1.811,-0.797c0.452,-0.38 1.274,-1.239 1.645,-2.126c0.155,-0.371 0.265,-0.75 0.022,-1.048c-0.179,-0.22 -0.366,-0.529 -0.732,-0.783c-0.536,-0.372 -1.356,-0.51 -1.905,-0.654c-0.405,-0.106 -0.715,-0.234 -0.88,-0.355l-0.284,-0.303l-0.135,-0.367l-0.008,-0.211l0.035,-0.196l0.078,-0.195l0.142,-0.209l0.198,-0.181l0.296,-0.154c0.151,-0.055 0.348,-0.092 0.587,-0.104c0.815,-0.042 2.571,0.294 4.235,-1.259c0.171,-0.159 0.288,-0.445 0.404,-0.845c0.246,-0.843 0.391,-2.096 0.438,-3.843c0.024,-0.91 0.026,-1.938 -0.208,-2.738c-0.142,-0.486 -0.367,-0.891 -0.896,-0.891c-1.675,0 -2.974,0.983 -4.031,2.21c-1.179,1.369 -2.058,3.057 -2.752,4.321c-0.483,0.88 -0.902,1.573 -1.25,1.916c-0.088,0.086 -0.174,0.157 -0.257,0.214l-0.221,0.125l-0.228,0.078l-0.267,0.031l-0.274,-0.034l-0.231,-0.083l-0.219,-0.132c-0.081,-0.058 -0.164,-0.131 -0.248,-0.22c-0.327,-0.343 -0.718,-1.037 -1.174,-1.917c-0.654,-1.262 -1.497,-2.948 -2.676,-4.314c-1.067,-1.236 -2.417,-2.217 -4.203,-2.217c-0.53,0 -0.754,0.405 -0.896,0.891c-0.234,0.8 -0.232,1.828 -0.208,2.738c0.046,1.747 0.192,3 0.438,3.843c0.116,0.4 0.233,0.686 0.403,0.845c1.665,1.553 3.421,1.217 4.235,1.259c0.24,0.012 0.437,0.049 0.588,0.104l0.295,0.154l0.199,0.181l0.142,0.209l0.078,0.195l0.035,0.196l-0.009,0.211l-0.135,0.368l-0.283,0.303c-0.165,0.12 -0.476,0.248 -0.88,0.355c-0.549,0.144 -1.369,0.281 -1.905,0.653c-0.366,0.254 -0.554,0.564 -0.732,0.783c-0.243,0.298 -0.133,0.677 0.022,1.048c0.371,0.887 1.193,1.746 1.645,2.127c0.757,0.637 1.311,0.9 1.789,0.8c0.311,-0.066 0.55,-0.29 0.772,-0.557c0.315,-0.381 0.577,-0.86 0.822,-1.337c0.394,-0.763 0.752,-1.521 1.138,-2.01c0.431,-0.544 0.929,-0.815 1.455,-0.815Z" style="fill-rule:nonzero;"/>
</svg>
</a>
<a href="/index.xml" target="_blank" rel="noopener noreferrer me"
    title="Rss">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9" />
    <path d="M4 4a16 16 0 0 1 16 16" />
    <circle cx="5" cy="19" r="1" />
</svg>
</a>
</div>
    <small class="footer_copyright">
        © 2025 J-Ponzo(TurboTartine).
        Propulsé par <a href="https://github.com/hugo-sid/hugo-blog-awesome" target="_blank" rel="noopener">Hugo blog awesome</a>.
    </small>
</footer><a href="#" title="Aller en haut" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    




    
    
        
    

    
    
        
    



    
    <script async src="http://localhost:1313/js/main.js" ></script>

    

</body>
</html>
