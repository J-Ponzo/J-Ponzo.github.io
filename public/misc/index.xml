<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Miscs on Turbo Tartine Games</title>
    <link>http://localhost:1313/misc/</link>
    <description>Recent content in Miscs on Turbo Tartine Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language><atom:link href="http://localhost:1313/misc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Distance Field</title>
      <link>http://localhost:1313/misc/distance_field/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/distance_field/</guid>
      
      <description>&lt;p&gt;Puisque la géométrie ne bouge pas, on peut pré-calculer en tout point de l’espace la distance qui le sépare de l’objet le plus proche. On appel cette donnée un distance field et on l’utilise comme structure acceleratrice dans plusieurs algorithmes (différentes techniques de ray tracing et d’ombrage, simulation de fluides…). On peut anisi faire fonctionner en temps réèl des effets dont une implémentation naïve sans structure acceleratrice serait beaucoup trop coûteuse pour être utilisée en temps réèl dans un jeu même avec du hardware moderne.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Glossaire</title>
      <link>http://localhost:1313/misc/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/glossary/</guid>
      
      <description>&lt;h2 id=&#34;anti-aliasing&#34;&gt;Anti-Aliasing&lt;/h2&gt;
&lt;p&gt;[Décrire ici tous les types d&amp;rsquo;anti-aliasing MSAA, FXAA, TAA &amp;hellip;]&lt;/p&gt;
&lt;h2 id=&#34;bloom&#34;&gt;Bloom&lt;/h2&gt;
&lt;h2 id=&#34;cel-shading&#34;&gt;Cel Shading&lt;/h2&gt;
&lt;h2 id=&#34;depth-of-field&#34;&gt;Depth of Field&lt;/h2&gt;
&lt;h2 id=&#34;draw-call&#34;&gt;Draw Call&lt;/h2&gt;
&lt;h2 id=&#34;fixed-function&#34;&gt;Fixed Function&lt;/h2&gt;
&lt;h2 id=&#34;fragment-shader&#34;&gt;Fragment-Shader&lt;/h2&gt;
&lt;h2 id=&#34;frame&#34;&gt;Frame&lt;/h2&gt;
&lt;h2 id=&#34;mesh&#34;&gt;Mesh&lt;/h2&gt;
&lt;h2 id=&#34;morph-target&#34;&gt;Morph Target&lt;/h2&gt;
&lt;h2 id=&#34;motion-blur&#34;&gt;Motion Blur&lt;/h2&gt;
&lt;h2 id=&#34;niveau-dabstraction&#34;&gt;Niveau d&amp;rsquo;Abstraction&lt;/h2&gt;
&lt;h2 id=&#34;pipeline-graphique&#34;&gt;Pipeline Graphique&lt;/h2&gt;
&lt;h2 id=&#34;pixel-lighting&#34;&gt;Pixel Lighting&lt;/h2&gt;
&lt;h2 id=&#34;post-process&#34;&gt;Post-Process&lt;/h2&gt;
&lt;h2 id=&#34;quad&#34;&gt;Quad&lt;/h2&gt;
&lt;h2 id=&#34;rasterisation&#34;&gt;Rasterisation&lt;/h2&gt;
&lt;h2 id=&#34;render-target&#34;&gt;Render Target&lt;/h2&gt;
&lt;h2 id=&#34;shader&#34;&gt;Shader&lt;/h2&gt;
&lt;p&gt;Un shader est un programme qui s&amp;rsquo;execute sur le GPU.&lt;/p&gt;
&lt;p&gt;Plus de détails dans cet article : &lt;a href=&#34;http://localhost:1313/posts/ddj_shaders/&#34;&gt;Dis donc Jamy : Comment ça marche un shader ?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;skeletal-animation&#34;&gt;Skeletal Animation&lt;/h2&gt;
&lt;h2 id=&#34;ssao&#34;&gt;SSAO&lt;/h2&gt;
&lt;h2 id=&#34;uv&#34;&gt;UV&lt;/h2&gt;
&lt;h2 id=&#34;vertex&#34;&gt;Vertex&lt;/h2&gt;
&lt;h2 id=&#34;vertex-color&#34;&gt;Vertex Color&lt;/h2&gt;
&lt;h2 id=&#34;vertex-lighting&#34;&gt;Vertex Lighting&lt;/h2&gt;
&lt;h2 id=&#34;vertex-shader&#34;&gt;Vertex Shader&lt;/h2&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection Captures</title>
      <link>http://localhost:1313/misc/reflection_capture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/reflection_capture/</guid>
      
      <description>&lt;p&gt;Simuler des reflexion exactes en temps réèl est très coûteux mais les reflection captures permettent une approximation convainquante. Le principe dans les grandes lignes est de pré-calculer une photo 360° depuis un point de l&amp;rsquo;espace et de se sevire des cette photo pour appliquer les reflections aux différents éléments à proximité de ce point avec plus ou moins d&amp;rsquo;intensité en fonction des paramètres de leurs materiaux. Le lien avec le postulat est peut être moins evident ici mais je classe quand même cette technique dans cette cathégorie car si elle premet un resultat convainquant malgré le fait que les objets dynamiques ne figurent pas dans les reflexions et que ces dernières sont toujours un peu décalées par rapport à où elles devraient réelement se trouver, c&amp;rsquo;est parce que la surabondance de surfaces statiques dans une scene de jeu vidéo garanti une certaine stabilité dans &amp;ldquo;l&amp;rsquo;ambience reflexive&amp;rdquo; générale en un endroit donné.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Static Lighting</title>
      <link>http://localhost:1313/misc/static_lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/static_lighting/</guid>
      
      <description>&lt;p&gt;la contribution des lumière sur l&amp;rsquo;environnement n&amp;rsquo;a pas besoin d&amp;rsquo;être calculée en temps réèl si les lumières sont elles aussi statiques. On peut les précalculer pendant le développement (les baker dans le jargon) et enregistrer le resultat directement dans une texture spéciale qu&amp;rsquo;on appel une &amp;ldquo;light map&amp;rdquo;. Cette light map sera directement &amp;ldquo;mélangé&amp;rdquo; aux textures de l&amp;rsquo;environnement par le jeu pour que ces dernières paraissent plus ou moins éclairées ou ombragées. En plus du gain de performence, cela permet d&amp;rsquo;avoir des lumières beaucoup plus détaillées car on dispose de tout le temps qu&amp;rsquo;on veut pour calculer cette lumière statique. Alors que si la lumière est calculée dynamiquement, on a que 16ms si ont veut avoir une chance d&amp;rsquo;assure le 60fps si cher à nos yeux de joueurs.&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
