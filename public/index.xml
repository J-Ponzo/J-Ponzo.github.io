<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Turbo Tartine Games</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in Home on Turbo Tartine Games</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Wed, 12 Mar 2025 10:20:34 +0100</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dis donc Jamy : Comment ça marche un shader ?</title>
      <link>http://localhost:1313/posts/ddj_shaders/</link>
      <pubDate>Wed, 12 Mar 2025 10:20:34 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/ddj_shaders/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Programmer un &lt;em&gt;shader&lt;/em&gt;&lt;/strong&gt; n&amp;rsquo;est pas plus difficile que de programmer n&amp;rsquo;importe quoi d&amp;rsquo;autre. Mais il est vrai que le formalisme peut être un peu &lt;strong&gt;déroutant la première fois&lt;/strong&gt; qu&amp;rsquo;on s&amp;rsquo;y frotte. Dans ce blog, je cherche à m&amp;rsquo;adresser à un public assez large. Pas uniquement à des programmeurs professionnels, et encore moins à des programmeurs graphiques spécifiquement. J&amp;rsquo;aimerais donc &lt;strong&gt;démystifier un peu le concept&lt;/strong&gt; pour que cela ne devienne pas un point de blocage.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Les prémices d&#39;OpenRE (Open Retro Engine)</title>
      <link>http://localhost:1313/projects/open_re/</link>
      <pubDate>Sun, 09 Mar 2025 06:28:42 +0100</pubDate>
      
      <guid>http://localhost:1313/projects/open_re/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Lorsque j&amp;rsquo;ai cherché à développer mon propre jeu en caméra fixe, j’ai rapidement réalisé une chose : les outils et ressources disponibles sur le sujet sont rares. Certes, on trouve quelques tutoriels pour gérer les caméras ou implémenter les déplacements du joueur. Mais je n&amp;rsquo;ai pas trouvé de réponse à la question qui m&amp;rsquo;intéresse réellement : &lt;em&gt;&amp;ldquo;Comment intégrer des éléments interactifs dans des décors précalculés ?&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;J&amp;rsquo;ai donc commencé à bricoler de mon côté pour trouver une solution à ce problème et je pense avoir un début de réponse :

    &lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
      &lt;iframe allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen=&#34;allowfullscreen&#34; loading=&#34;eager&#34; referrerpolicy=&#34;strict-origin-when-cross-origin&#34; src=&#34;https://www.youtube.com/embed/ok0o0HhgfeY?autoplay=0&amp;amp;controls=1&amp;amp;end=0&amp;amp;loop=0&amp;amp;mute=0&amp;amp;start=0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; title=&#34;YouTube video&#34;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>À propos</title>
      <link>http://localhost:1313/pages/about/</link>
      <pubDate>Sun, 09 Mar 2025 06:26:08 +0100</pubDate>
      
      <guid>http://localhost:1313/pages/about/</guid>
      
      <description>&lt;h2 id=&#34;hello-world-&#34;&gt;Hello World !&lt;/h2&gt;
&lt;p&gt;Bienvenue sur Turbo Tartine Games, ce petit coin d’Internet dans lequel je partage ma passion pour le développement de jeux vidéo.&lt;/p&gt;
&lt;h2 id=&#34;qui-suis-je-&#34;&gt;Qui suis-je ?&lt;/h2&gt;
&lt;p&gt;Je m’appelle Jérémy, je suis passionné de jeux vidéo depuis toujours et j’ai la chance d’avoir pu en faire un métier. Je travaille dans un studio lyonnais du nom de &lt;a href=&#34;https://bsky.app/profile/wanadevstudio.com&#34;&gt;WanadevStudio&lt;/a&gt;. Mes journées consistent à développer des jeux (principalement en VR) sous Unreal Engine. Mais lorsque la nuit tombe, je deviens TurboTartine. Sous cette identité pas vraiment secrète, je continue de faire des jeux, mais sur mon temps libre. Cette double vie me permet d’appréhender cette passion sous deux angles très différents :&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ode à la caméra fixe et aux contrôles du tank</title>
      <link>http://localhost:1313/posts/i_love_fixed_cams/</link>
      <pubDate>Sun, 09 Mar 2025 06:26:08 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/i_love_fixed_cams/</guid>
      
      <description>&lt;h2 id=&#34;préembule&#34;&gt;Préembule&lt;/h2&gt;
&lt;p&gt;Je travaille actuellement sur &lt;strong&gt;OpenRE (Open Retro Engine)&lt;/strong&gt; : une technologie permettant de créer des jeux vidéo en caméra fixe avec des arrière-plans précalculés. Si vous êtes déjà curieux, vous trouverez plus d&amp;rsquo;information sur &lt;a href=&#34;http://localhost:1313/projects/open_re/&#34;&gt;cette page&lt;/a&gt;. Vous pourrez également suivre son avancement à travers les devlogs que je publie régulièrement.&lt;/p&gt;
&lt;p&gt;Mais il est plus probable que vous vous demandiez : &lt;em&gt;&amp;ldquo;Pourquoi investir du temps et de l&amp;rsquo;énergie dans cette technique du passé ?&amp;rdquo;&lt;/em&gt;, &lt;em&gt;&amp;ldquo;Qu&amp;rsquo;a-t-on à y gagner ?&amp;rdquo;&lt;/em&gt;, &lt;em&gt;&amp;ldquo;Est-ce que le monde en a vraiment besoin ?&amp;rdquo;&lt;/em&gt;. Ou peut-être, que vous n’êtes pas familier avec ce genre vidéoludique un peu oublié et que vous souhaitez découvrir son potentiel.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Harmonisation de l&#39;Albedo</title>
      <link>http://localhost:1313/projects/open_re_poc_devlog_1/</link>
      <pubDate>Sat, 08 Mar 2025 13:45:59 +0100</pubDate>
      
      <guid>http://localhost:1313/projects/open_re_poc_devlog_1/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Bienvenu dans ce tout premier devlog d&amp;rsquo;OpenRE : le develog Zéro ! Cette série a pour but de documenter la phase de POC (proof of concept) du projet. Le format sera assez simple. Tout au long du développement, je prendrai des notes dès que je tomberai sur un sujet intéressant. Chaque mois (si j’arrive à m’y tenir), je sélectionnerai les plus pertinents pour les présenter dans un nouveau numéro.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>OpenRE devlog 0 : Oracle Driven Development</title>
      <link>http://localhost:1313/projects/open_re_poc_devlog_0/</link>
      <pubDate>Fri, 21 Feb 2025 12:51:02 +0100</pubDate>
      
      <guid>http://localhost:1313/projects/open_re_poc_devlog_0/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Bienvenue dans ce tout premier devlog d&amp;rsquo;OpenRE : le devlog Zéro ! Cette série a pour but de documenter la phase de proof of concept (POC) du projet.&lt;/p&gt;
&lt;p&gt;Si vous ne l&amp;rsquo;avez pas encore lu, je vous recommande de consulter l&amp;rsquo;article &lt;a href=&#34;http://localhost:1313/projects/open_re/&#34;&gt;Les prémices d&amp;rsquo;OpenRE (Open Retro Engine)&lt;/a&gt;, qui vous donnera une vision globale du projet. J&amp;rsquo;y introduis notamment quelques notions et un peu de terminologie. Il est préférable de l&amp;rsquo;avoir parcouru pour mieux contextualiser ce que je raconte dans les devlogs.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Distance Field</title>
      <link>http://localhost:1313/misc/distance_field/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/distance_field/</guid>
      
      <description>&lt;p&gt;Puisque la géométrie ne bouge pas, on peut pré-calculer en tout point de l’espace la distance qui le sépare de l’objet le plus proche. On appel cette donnée un distance field et on l’utilise comme structure acceleratrice dans plusieurs algorithmes (différentes techniques de ray tracing et d’ombrage, simulation de fluides…). On peut anisi faire fonctionner en temps réèl des effets dont une implémentation naïve sans structure acceleratrice serait beaucoup trop coûteuse pour être utilisée en temps réèl dans un jeu même avec du hardware moderne.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Glossaire</title>
      <link>http://localhost:1313/misc/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/glossary/</guid>
      
      <description>&lt;h2 id=&#34;anti-aliasing&#34;&gt;Anti-Aliasing&lt;/h2&gt;
&lt;p&gt;[Décrire ici tous les types d&amp;rsquo;anti-aliasing MSAA, FXAA, TAA &amp;hellip;]&lt;/p&gt;
&lt;h2 id=&#34;bloom&#34;&gt;Bloom&lt;/h2&gt;
&lt;h2 id=&#34;cel-shading&#34;&gt;Cel Shading&lt;/h2&gt;
&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;p&gt;C&amp;rsquo;est l&amp;rsquo;acronyme de Central Processing Unit : l&amp;rsquo;unité de calcule principale d&amp;rsquo;un ordinateur. Il s&amp;rsquo;agit tout simplement de votre processeur.&lt;/p&gt;
&lt;h2 id=&#34;depth-of-field&#34;&gt;Depth of Field&lt;/h2&gt;
&lt;h2 id=&#34;draw-call&#34;&gt;Draw Call&lt;/h2&gt;
&lt;p&gt;Un draw call est une commande envoyée au GPU pour lui demander de traiter un ensemble de primitives géométriques (généralement des triangles) afin de les rendre à l&amp;rsquo;écran (ou dans une &lt;em&gt;render target&lt;/em&gt;).&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Reflection Captures</title>
      <link>http://localhost:1313/misc/reflection_capture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/reflection_capture/</guid>
      
      <description>&lt;p&gt;Simuler des reflexion exactes en temps réèl est très coûteux mais les reflection captures permettent une approximation convainquante. Le principe dans les grandes lignes est de pré-calculer une photo 360° depuis un point de l&amp;rsquo;espace et de se sevire des cette photo pour appliquer les reflections aux différents éléments à proximité de ce point avec plus ou moins d&amp;rsquo;intensité en fonction des paramètres de leurs materiaux. Le lien avec le postulat est peut être moins evident ici mais je classe quand même cette technique dans cette cathégorie car si elle premet un resultat convainquant malgré le fait que les objets dynamiques ne figurent pas dans les reflexions et que ces dernières sont toujours un peu décalées par rapport à où elles devraient réelement se trouver, c&amp;rsquo;est parce que la surabondance de surfaces statiques dans une scene de jeu vidéo garanti une certaine stabilité dans &amp;ldquo;l&amp;rsquo;ambience reflexive&amp;rdquo; générale en un endroit donné.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Static Lighting</title>
      <link>http://localhost:1313/misc/static_lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/misc/static_lighting/</guid>
      
      <description>&lt;p&gt;la contribution des lumière sur l&amp;rsquo;environnement n&amp;rsquo;a pas besoin d&amp;rsquo;être calculée en temps réèl si les lumières sont elles aussi statiques. On peut les précalculer pendant le développement (les baker dans le jargon) et enregistrer le resultat directement dans une texture spéciale qu&amp;rsquo;on appel une &amp;ldquo;light map&amp;rdquo;. Cette light map sera directement &amp;ldquo;mélangé&amp;rdquo; aux textures de l&amp;rsquo;environnement par le jeu pour que ces dernières paraissent plus ou moins éclairées ou ombragées. En plus du gain de performence, cela permet d&amp;rsquo;avoir des lumières beaucoup plus détaillées car on dispose de tout le temps qu&amp;rsquo;on veut pour calculer cette lumière statique. Alors que si la lumière est calculée dynamiquement, on a que 16ms si ont veut avoir une chance d&amp;rsquo;assure le 60fps si cher à nos yeux de joueurs.&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
